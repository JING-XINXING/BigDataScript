package org.bds.task;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.bds.data.Data;
import org.bds.data.DataTask;
import org.bds.lang.BdsNode;
import org.bds.lang.value.Value;
import org.bds.lang.value.ValueList;
import org.bds.run.BdsThreads;
import org.bds.util.Timer;

/**
 * Output and Input files (and tasks) that are required for a task to successfully execute
 *
 * @author pcingola
 */
public class TaskDependency implements Serializable {

	private static final long serialVersionUID = -2026628428708457981L;

	boolean debug;
	protected BdsNode bdsNode; // The node that created this 'TaskDependency' (only used for logging & debugging purposes)
	protected List<Data> inputs; // Input files generated by this task
	protected List<Data> outputs; // Output files generated by this task
	protected String checkOutputs; // Errors that pop-up when checking output files
	protected List<Task> tasks; // Task that need to finish before this one is executed

	public TaskDependency() {
		this(null);
	}

	public TaskDependency(BdsNode bdsNode) {
		this.bdsNode = bdsNode;
		outputs = new ArrayList<>();
		inputs = new ArrayList<>();
		tasks = new ArrayList<>();
	}

	public void add(Task task) {
		tasks.add(task);
	}

	/**
	 * Add all dependencies from 'taskDependency' to this this one
	 */
	public void add(TaskDependency taskDependency) {
		addInputs(taskDependency.getInputs());
		addOutput(taskDependency.getOutputs());
		tasks.addAll(taskDependency.getTasks());
	}

	public void addInput(Data input) {
		if (input instanceof DataTask) {
			// Is 'input' a task ID?
			Task task = TaskDependecies.get().getTask(input.getUrlOri());
			tasks.add(task);
		} else {
			// Not a taksID, must be an input 'data file'
			inputs.add(input);
		}
	}

	/**
	 * Add input. It can be either a taskId or a file
	 */
	public void addInput(String input) {
		// Is 'input' a task ID?
		Task task = TaskDependecies.get().getTask(input);

		if (task != null) {
			// It is a taskId, add task as dependency
			tasks.add(task);
		} else {
			// Not a taksID, must be an input 'data file'
			addInput(BdsThreads.data(input));
		}
	}

	/**
	 * Add a list of inputs
	 */
	public void addInputs(Collection<Data> inputs) {
		for (Data in : inputs)
			addInput(in);
	}

	public void addInputs(ValueList inputs) {
		for (Value in : inputs)
			addInput(in.asString());
	}

	/**
	 * Add a list of outputs
	 */
	public void addOutput(Collection<Data> outputs) {
		for (Data out : outputs)
			addOutput(out);
	}

	public void addOutput(Data output) {
		outputs.add(output);
	}

	/**
	 * Add output
	 */
	public void addOutput(String output) {
		addOutput(BdsThreads.data(output));
	}

	public void addOutput(ValueList outputs) {
		for (Value out : outputs)
			addOutput(out.asString());
	}

	/**
	 * Check if output files are OK
	 * @return true if OK, false there is an error (output file does not exist or has zero length)
	 */
	public String checkOutputFiles(Task task) {
		if (checkOutputs != null) return checkOutputs;
		if (!task.isStateFinished() || outputs == null) return ""; // Nothing to check

		checkOutputs = "";
		for (Data dfile : outputs) {
			if (!dfile.exists()) checkOutputs += "Error: Output file '" + dfile + "' does not exist.";
			else if ((!task.isAllowEmpty()) && (dfile.size() <= 0)) checkOutputs += "Error: Output file '" + dfile + "' has zero length.";
		}

		if (task.verbose && !checkOutputs.isEmpty()) Timer.showStdErr(checkOutputs);
		return checkOutputs;
	}

	/**
	 * Mark output files to be deleted on exit
	 */
	public void deleteOutputFilesOnExit() {
		for (Data dfile : outputs) {
			if (dfile.exists()) dfile.deleteOnExit();
		}
	}

	/**
	 * Calculate the result of '<-' operator give two collections files (left hand side and right hand-side)
	 */
	public boolean depOperator() {
		// Empty dependency is always true
		if (outputs.isEmpty() && inputs.isEmpty()) return true;
		if (debug) log("Evaluating dependencies: " + (bdsNode != null && bdsNode.getFileName() != null ? (bdsNode.getFileName() + ":" + bdsNode.getLineNum()) : "null"));

		//---
		// Left hand side
		// Calculate minimum modification time
		//---

		long minModifiedLeft = Long.MAX_VALUE;
		for (Data dataOut : outputs) {
			// Any 'left' file does not exists? => We need to build this dependency
			if (!dataOut.exists()) {
				if (debug) log("Left hand side: file '" + dataOut + "' doesn't exist");
				return true;
			}

			if (dataOut.isFile() && dataOut.size() <= 0) {
				if (debug) log("Left hand side: file '" + dataOut + "' is empty");
				return true; // File is empty? => We need to build this dependency.
			} else if (dataOut.isDirectory()) {
				// Notice: If it is a directory, we must rebuild if it is empty
				List<Data> dirList = dataOut.list();
				if (dirList.isEmpty()) {
					if (debug) log("Left hand side: file '" + dataOut + "' is an empty dir");
					return true;
				}
			}

			// Analyze modification time
			long modTime = dataOut.getLastModified().getTime();
			minModifiedLeft = Math.min(minModifiedLeft, modTime);
			if (debug) log("Left hand side: file '" + dataOut + "' modified on " + modTime + ". Min modification time: " + minModifiedLeft);
		}

		//---
		// Right hand side
		// Calculate maximum modification time
		//---

		long maxModifiedRight = Long.MIN_VALUE;
		for (Data dataIn : inputs) {
			// Is this file scheduled to be modified by a pending task? => Time will change => We'll need to update
			List<Task> taskOutList = TaskDependecies.get().getTasksByOutput(dataIn);
			if (taskOutList != null && !taskOutList.isEmpty()) {
				for (Task t : taskOutList) {
					// If the task modifying 'file' is not finished => We'll need to update
					if (!t.isDone()) {
						if (debug) log("Right hand side: file '" + dataIn + "' will be modified by task '" + t.getId() + "' (task state: '" + t.getTaskState() + "')");
						return true;
					}
				}
			}

			if (dataIn.exists()) {
				// Update max time
				long modTime = dataIn.getLastModified().getTime();
				maxModifiedRight = Math.max(maxModifiedRight, modTime);
				if (debug) log("Right hand side: file '" + dataIn + "' modified on " + modTime + ". Max modification time: " + maxModifiedRight);
			} else {
				// Make sure that we schedule the task if the input file doesn't exits
				// The reason to do this, is that probably the input file was defined
				// by some other task that is pending execution.
				if (debug) log("Right hand side: file '" + dataIn + "' doesn't exist");
				return true;
			}
		}

		// Have all 'left' files been modified before 'right' files?
		// I.e. Have all goals been created after the input files?
		boolean ret = (minModifiedLeft < maxModifiedRight);
		if (debug) log("Modification times, minModifiedLeft (" + minModifiedLeft + ") < maxModifiedRight (" + maxModifiedRight + "): " + ret);
		return ret;
	}

	public List<Data> getInputs() {
		return inputs;
	}

	public List<Data> getOutputs() {
		return outputs;
	}

	public List<Task> getTasks() {
		return tasks;
	}

	public boolean hasTasks() {
		return !tasks.isEmpty();
	}

	boolean isTask(String tid) {
		return TaskDependecies.get().hasTask(tid);
	}

	void log(String msg) {
		if (bdsNode != null) bdsNode.log(msg);
		else Timer.showStdErr(getClass().getSimpleName() + " : " + msg);
	}

	public void setDebug(boolean debug) {
		this.debug = debug;
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("( ");

		if ((outputs != null && !outputs.isEmpty()) || (inputs != null && !inputs.isEmpty())) {

			if (outputs != null && !outputs.isEmpty()) {
				boolean comma = false;
				for (Data d : outputs) {
					sb.append((comma ? ", " : "") + "'" + d + "'");
					comma = true;
				}
			}

			sb.append(" <- ");

			if (inputs != null && !inputs.isEmpty()) {
				boolean comma = false;
				for (Data d : inputs) {
					sb.append((comma ? ", " : "") + "'" + d + "'");
					comma = true;
				}
			}
		}
		sb.append(" )");

		return sb.toString();
	}

}
